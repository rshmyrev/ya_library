#!/usr/bin/env python3.4
# -*- coding: utf-8 -*-
import top_query4 as top
'''
Ниже приведены параметры настройки работы скрипта. Если нужно
использовать какой-либо параметр, его достаточно раскомментировать -
убрать "# " из начала строки. Везде приведены значения по умолчанию.
Все параметры сгруппированы в несколько функциональных блоков:
file_params - настройки, касающиеся входных и выходных файлов
split_params - если необходимо разделитель топ по какому-либо ключу
(например, по GeoID)
transform_params - если ключи необходимо преобразовать
(например, GeoID перевести в названия регионов)
check_params - если нужно удалить/сохранить запросы, подходящие под условие
change_params - если нужно изменить режим работы с запросами
'''

# Названия файлов в кавычках. Через запятую. По умолчанию 'input'.
names = [
    'input',
]

# Папки, где лежат исходные файлы и куда положить обработанные.
# Можно писать путь относительно папки со скриптом. По умолчанию, скрипт берёт
# файлы из папки 'Data' и кладёт в папку 'Output'
path_in = 'Data'     # папка, где лежат исходные файлы
path_out = 'Output'  # папка назначения

# Расширение и кодировка файлов. Если в файле несколько столбцов, то нужно
# указать разделитель и номер столбца, в котором находятся формулировки
# запросов. Если у формулировок уже есть количество, то нужно указать
# соответствующий столбец с цифрами.
file_params = {
    # 'extension': '.txt',   # расширение файлов
    # 'encoding': 'utf-8',   # кодировка файлов
    # 'delimiter': '\t',     # разделитель столбцов
    # 'col_query': 1,        # номер столбца с формулировкой запроса
    # 'col_count': False,    # номер столбца с количеством запросов
}

# Параметры работы с запросами. 'lower' - сделать все строчными, чтобы
# суммировались запросы в разных регистрах (например, "НДС" и "ндс").
# Если необходимо разбить запрос на части (например, на слова) и считать
# топ частей (слов), то указываем разделитель, по которому будем бить запрос.
# Например, по пробельным символам: 'separator': '\s'. Поддерживаются
# регулярные выражения
# Req_per_day — считает количество запросов по дням, 
# col_query должен ссылаться на колонку с unix-временем
change_params = {
    # 'lower': True,       # преобразовать запрос в строчные буквы
    # 'separator': False,  # разделитель запроса на части
    #'req_per_day': True   # подсчитать количество запросов в день
}

# Разбить топ по отдельным файлам, используя для разбиения ключи из
# какого-либо столбца. Может понадобиться, например, для создания топов по
# регионам. Для включения поставить 'split_by_key': True
# и указать номер столбца в 'col_key' (например, 'col_key': 4)
split_params = {
    # 'split_by_key': False,  # разбить топ по отдельным файлам
    # 'col_key': False,       # номер столбца с ключом для разбиения по файлам
}

# Преобразовать ключи, используя шаблон. Например, у нас в файле указаны
# GeoID местности, а нам нужны названия регионов. Тогда мы берём файл, в
# котором каждому GeoID сопоставлен регион, и по нему делаем преобразование.
# По умолчанию это файл 'ID_Regions.txt', лежащий в папке со скриптом.
# Разделитель столбцов - табуляция. Старые значения находятся в первом
# столбце, а новые во втором. В том случае, если для какого-либо ключа не
# найдётся соответствия в файле, ему припишется значение по умолчанию.
transform_params = {
    # 'transform_key': False,          # преобразовать ключи, используя шаблон
    # 'key_file': 'ID_Regions.txt',    # файл с шаблоном для преобразования
    # 'key_file_encoding': 'utf-8',    # кодировка файла
    # 'key_file_delimiter': '\t',      # разделитель столбцов
    # 'col_old_key': 1,                # номер столбца со старым ключом
    # 'col_new_key': 2,                # номер столбца с новым ключом
    # 'key_default': '!KeyNotInDict',  # значение ключа по умолчанию
}

# Сохранить или удалить из файла запросы, подходящие под условие
# (например, соответствующие регулярному выражению). Можно проверять запрос
# целиком или на наличие частей, подходящих под регулярное выражение.
# Соответственно режимы работы: 'full'/'reg'.
# Если проверяем целиком, но нужно указать список запросов, на соответствие
# которым проверяем. Формат такой же как и в указании имён файлов:
# ['запрос1', 'запрос2', 'запрос3', ...]
# Если проверяем на наличие частей, подходящих под регулярку, то нужно написать
# текст регулярки. Если из регулярки есть исключения, пишем текст исключений.
# Параметр 'action' определяет, что делаем с запросом, подходящим под условие.
# 'delete' - удаляем, 'save' - сохраняем (и удаляем все неподходящие).
check_params = {
    # 'compliance_test': False,     # проверить запрос
    # 'check_type': False,          # тип проверки: 'full'/'reg'
    # 'query_list': False,          # список запросов для проверки
    # 'reg_text': False,            # текст регулярки
    # 'reg_exception_text': False,  # текст исключения из регулярки
    # 'action': False,              # что сделать с запросом: 'delete'/'save'
}

# Далее идёт служебный код. Просто объединяем все словари в один, чтобы
# передать функции в виде именованных аргументов.
params = {}
params.update(file_params)
params.update(split_params)
params.update(transform_params)
params.update(check_params)
params.update(change_params)

# Вызываем функцию
top.top(names, path_in, path_out, **params)
